{"version":3,"sources":["webpack:///../modules/core/src/lib/loader-utils/normalize-loader.js","webpack:///../modules/core/src/utils/assert.js","webpack:///../modules/core/src/lib/register-loaders.js","webpack:///../modules/core/src/javascript-utils/text-encoding.js","webpack:///../modules/core/src/utils/globals.js","webpack:///../modules/core/src/javascript-utils/memory-copy-utils.js","webpack:///../modules/core/src/javascript-utils/binary-utils.js","webpack:///../modules/core/src/lib/fetch/fetch-file-browser.js","webpack:///../modules/core/src/lib/fetch/file-aliases.js","webpack:///../modules/core/src/lib/fetch/fetch-file.js","webpack:///../modules/core/src/lib/loader-utils/auto-detect-loader.js","webpack:///../modules/core/src/lib/loader-utils/null-log.js","webpack:///../modules/core/src/lib/parse-with-worker.js","webpack:///../modules/core/src/javascript-utils/is-type.js","webpack:///../modules/core/src/lib/loader-utils/get-data.js","webpack:///../modules/core/src/lib/parse-with-loader.js","webpack:///../modules/core/src/lib/parse.js","webpack:///../modules/core/src/lib/load.js"],"names":["isLoaderObject","loader","Array","worker","normalizeLoader","options","assert","Object","assign","extension","extensions","parseTextSync","text","condition","message","Error","__webpack_require__","d","__webpack_exports__","registeredLoaders","registerLoaders","loaders","_iterator","_isArray","isArray","_i","Symbol","iterator","_ref","length","next","done","value","_iterator2","_isArray2","_i2","_ref2","getRegisteredLoaders","TextDecoder","TextEncoder","module","process","global","isBrowser","String","browser","self","window","document","padTo4Bytes","byteLength","concatenateArrayBuffers","source1","source2","sourceArray1","Uint8Array","sourceArray2","temp","isArrayBuffer","x","ArrayBuffer","isBuffer","Buffer","toArrayBuffer","data","buffer","_text_encoding__WEBPACK_IMPORTED_MODULE_4__","encode","fetchFile","_x","_x2","_fetchFile","apply","this","arguments","_callee","url","regenerator_default","a","wrap","_context","prev","fetch","abrupt","sent","stop","pathPrefix","fileAliases","resolvePath","filename","alias","replacement","fetch_file_fetchFile","fetch_fetch_file_fetchFile","func","node","EXT_PATTERN","autoDetectLoader","match","loaderExtension","findLoaderByExtension","_loader","_iterator3","_isArray3","_i3","_ref3","findLoaderByExamingInitialData","NullLog","log","info","warn","error","workerCache","Map","parseWithWorker","workerSource","workerURL","blob","Blob","type","URL","Worker","getWorker","removeNontransferableOptions","parse","rawData","opts","Promise","resolve","reject","evt","arraybuffer","isFetchResponse","Response","body","ERR_DATA","getUrlFromData","getArrayBufferOrStringFromDataSync","arrayBuffer","binary","text_encoding","textDecoder","getArrayBufferOrStringFromData","_getArrayBufferOrStringFromData","t0","parseWithLoader","_x3","_x4","_parseWithLoader","parseSync","parse_parse","_parse","mergeLoaderAndUserOptions","DEFAULT_OPTIONS","dataType","load","_x5","_x6","_load","_callee2","_context2","loadAndParse"],"mappings":"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","file":"2-f9b36ff3326c1dd645ff.js","sourcesContent":["import assert from '../../utils/assert';\n\nexport function isLoaderObject(loader) {\n  if (!loader) {\n    return false;\n  }\n\n  if (Array.isArray(loader)) {\n    loader = loader[0];\n  }\n\n  const hasParser =\n    loader.parseTextSync ||\n    loader.parseSync ||\n    loader.parse ||\n    loader.loadAndParse ||\n    loader.parseStream || // TODO Replace with parseInBatches\n    loader.parseInBatches ||\n    // loader.parseInBatchesSync || // Optimization only, parseInBatches needed\n    loader.worker;\n\n  return hasParser;\n}\n\nexport function normalizeLoader(loader) {\n  assert(isLoaderObject(loader));\n\n  // NORMALIZE [LOADER, OPTIONS] => LOADER\n\n  // If [loader, options], create a new loaders object with options merged in\n  let options;\n  if (Array.isArray(loader)) {\n    loader = loader[0];\n    options = loader[1];\n    loader = {\n      ...loader,\n      options: {...loader.options, options}\n    };\n  }\n\n  // NORMALIZE LOADER.EXTENSIONS\n\n  // Remove `extension`` prop, replace with `extensions``\n  if (loader.extension) {\n    loader.extensions = loader.extensions || [loader.extension];\n    delete loader.extension;\n  }\n\n  // Ensure loader.extensions is an array\n  if (!Array.isArray(loader.extensions)) {\n    loader.extensions = [loader.extensions];\n  }\n\n  assert(loader.extensions && loader.extensions.length > 0 && loader.extensions[0]);\n\n  // NORMALIZE text and binary flags\n\n  // Ensure at least one of text/binary flags are properly set\n  if (loader.parseTextSync) {\n    loader.text = true;\n  }\n\n  if (!loader.text) {\n    loader.binary = true;\n  }\n\n  return loader;\n}\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n","import {normalizeLoader} from './loader-utils/normalize-loader';\n\nconst registeredLoaders = {};\n\nexport function registerLoaders(loaders) {\n  loaders = Array.isArray(loaders) ? loaders : [loaders];\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n    for (const extension of loader.extensions) {\n      registeredLoaders[extension] = loader;\n    }\n  }\n}\n\nexport function getRegisteredLoaders() {\n  return Object.values(registeredLoaders);\n}\n","/* global TextEncoder,TextDecoder */\nif (typeof TextDecoder === 'undefined' || typeof TextEncoder === 'undefined') {\n  module.exports = {};\n} else {\n  module.exports = {TextEncoder, TextDecoder};\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\n/* global process, window, global, document */\nconst isBrowser =\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\n/* global self, window, global, document */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_ = globals.self || globals.window || globals.global;\nconst window_ = globals.window || globals.self || globals.global;\nconst global_ = globals.global || globals.self || globals.window;\nconst document_ = globals.document || {};\n\nexport {isBrowser, self_ as self, window_ as window, global_ as global, document_ as document};\n","export function padTo4Bytes(byteLength) {\n  return (byteLength + 3) & ~3;\n}\n\n/* Creates a new Uint8Array based on two different ArrayBuffers\n * @private\n * @param {ArrayBuffers} buffer1 The first buffer.\n * @param {ArrayBuffers} buffer2 The second buffer.\n * @return {ArrayBuffers} The new ArrayBuffer created out of the two.\n */\nexport function copyArrayBuffer(\n  targetBuffer,\n  sourceBuffer,\n  byteOffset,\n  byteLength = sourceBuffer.byteLength\n) {\n  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n  const sourceArray = new Uint8Array(sourceBuffer);\n  targetArray.set(sourceArray);\n  return targetBuffer;\n}\n\n/**\n * Copy from source to target at the targetOffset\n *\n * @param {ArrayBuffer|TypedArray} source - The data to copy\n * @param {TypedArray} target - The destination to copy data into\n * @param {Number} targetOffset - The start offset into target to place the copied data\n *\n * @return {Number} Returns the new offset taking into account proper padding\n */\nexport function copyToArray(source, target, targetOffset) {\n  let sourceArray;\n\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    // Pack buffer onto the big target array\n    //\n    // 'source.data.buffer' could be a view onto a larger buffer.\n    // We MUST use this constructor to ensure the byteOffset and byteLength is\n    // set to correct values from 'source.data' and not the underlying\n    // buffer for target.set() to work properly.\n    const srcByteOffset = source.byteOffset;\n    const srcByteLength = source.byteLength;\n    sourceArray = new Uint8Array(source.buffer, srcByteOffset, srcByteLength);\n  }\n\n  // Pack buffer onto the big target array\n  target.set(sourceArray, targetOffset);\n\n  return targetOffset + padTo4Bytes(sourceArray.byteLength);\n}\n\nexport function concatenateArrayBuffers(source1, source2) {\n  const sourceArray1 = source1 instanceof ArrayBuffer ? new Uint8Array(source1) : source1;\n  const sourceArray2 = source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;\n  const temp = new Uint8Array(sourceArray1.byteLength + sourceArray2.byteLength);\n  temp.set(sourceArray1, 0);\n  temp.set(sourceArray2, sourceArray1.byteLength);\n  return temp;\n}\n","/* global FileReader, Blob, ArrayBuffer, Buffer */\nimport assert from '../utils/assert';\nimport {TextEncoder} from './text-encoding';\n\nexport const isArrayBuffer = x => x && x instanceof ArrayBuffer;\nexport const isBlob = x => x && typeof Blob !== 'undefined' && x instanceof Blob;\nexport const isBuffer = x => x && x instanceof Buffer;\n\nexport function toArrayBuffer(data) {\n  if (isArrayBuffer(data)) {\n    return data;\n  }\n\n  // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n  if (isBuffer(data)) {\n    const typedArray = new Uint8Array(data);\n    return typedArray.buffer;\n  }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    return data.buffer;\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  return assert(false);\n}\n\nexport function blobToArrayBuffer(blob) {\n  return new Promise((resolve, reject) => {\n    let arrayBuffer;\n    const fileReader = new FileReader();\n    fileReader.onload = event => {\n      arrayBuffer = event.target.result;\n    };\n    fileReader.onloadend = event => resolve(arrayBuffer);\n    fileReader.onerror = reject;\n    fileReader.readAsArrayBuffer(blob);\n  });\n}\n\nexport function toDataView(buffer) {\n  return new DataView(toArrayBuffer(buffer));\n}\n","/* global fetch */\nimport assert from '../../utils/assert';\n\nconst DEFAULT_OPTIONS = {\n  dataType: 'arrayBuffer',\n  // TODO - this was mostly set to true to make test cases work\n  nothrow: true\n};\n\nconst isDataURL = url => url.startsWith('data:');\n// const isFileURL = url => typeof File !== 'undefined' && url instanceof File;\n\n// Returns a promise that resolves to a response object\nexport async function fetchFile(url, options) {\n  return await fetch(url, options);\n\n  // TODO - SUPPORT reading from `File` objects\n  // if (typeof File !== 'undefined' && uri instanceof File) {\n  //   readFileObject(uri, options);\n  // }\n}\n\n// In a few cases (data URIs, files under Node) \"files\" can be read synchronously\nexport function readFileSync(uri, options = {}) {\n  options = getReadFileOptions(options);\n\n  if (isDataURL(uri)) {\n    // TODO - removed until decodeDataUri does not depend on Node.js Buffer\n    //   return decodeDataUri(uri);\n  }\n\n  if (!options.nothrow) {\n    // throw new Error('Cant load URI synchronously');\n    assert(false);\n  }\n\n  return null;\n}\n\n// DEPRECATED\n\n// Creates a readable stream to\n// * http/http urls\n// * data urls\n// TODO - does not support opening a stream on a `File` objects\nexport async function createReadStream(url, options) {\n  return fetch(url, options).then(res => res.body);\n}\n\n// HELPER FUNCTIONS\n\nfunction getReadFileOptions(options = {}) {\n  options = Object.assign({}, DEFAULT_OPTIONS, options);\n  options.responseType = options.responseType || options.dataType;\n  return options;\n}\n\n/**\n * File reader function for the browser\n * @param {File|Blob} file  HTML File or Blob object to read as string\n * @returns {Promise.string}  Resolves to a string containing file contents\n/* global File, FileReader\nfunction readFileObject(file, options) {\n  return new Promise((resolve, reject) => {\n    try {\n      const reader = new FileReader();\n      reader.onerror = error => reject(new Error(error));\n      reader.onabort = () => reject(new Error('Read aborted.'));\n      reader.onload = () => resolve(reader.result);\n      if (options.dataType !== 'arraybuffer') {\n        reader.readAsText(file);\n      } else {\n        reader.readAsArrayBuffer(file);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n*/\n\n/* Reads raw file data from:\n// * http/http urls\n// * data urls\n// * File/Blob objects\n// etc?\nasync function readFile(uri, options = {}) {\n  options = getReadFileOptions(options);\n\n  // NOTE: data URLs are decoded by fetch\n\n  // SUPPORT reading from `File` objects\n  if (typeof File !== 'undefined' && uri instanceof File) {\n    readFileObject(uri, options);\n  }\n\n  // In a web worker, XMLHttpRequest throws invalid URL error if using relative path\n  // resolve url relative to original base\n  // TODO - merge this into `resolvePath?\n  uri = new URL(uri, location.href).href;\n\n  // Browser: Try to load all URLS via fetch, as they can be local requests (e.g. to a dev server)\n  const response = await fetch(uri, options);\n  return response[options.dataType]();\n}\n*/\n","// Simple file alias mechanisms for tests.\n\nlet pathPrefix = '';\nconst fileAliases = {};\n\n/*\n * Set a relative path prefix\n */\nexport function setPathPrefix(prefix) {\n  pathPrefix = prefix;\n}\n\nexport function getPathPrefix() {\n  return pathPrefix;\n}\n\n// Note: addAliases are not exported at the moment, they are only for loaders.gl testing\nexport function addAliases(aliases) {\n  Object.assign(fileAliases, aliases);\n}\n\nexport function resolvePath(filename) {\n  for (const alias in fileAliases) {\n    if (filename.startsWith(alias)) {\n      const replacement = fileAliases[alias];\n      return filename.replace(alias, replacement);\n    }\n  }\n  filename += pathPrefix;\n  return filename;\n}\n","import {isBrowser} from '../../utils/globals';\n\n// fetch-file-node is excluded from build under browser so don't do indivdual imports\nimport * as node from '../../node/fetch/fetch-file-node';\n\n// Import individual symbols for browser version to ensure tree-shaking is enabled\nimport {\n  fetchFile as browserFetchFile,\n  readFileSync as browserReadFileSync,\n  createReadStream as browserCreateReadStream\n} from './fetch-file-browser';\n\nimport {resolvePath} from './file-aliases';\n\n// Reads raw file data from:\n// * http/http urls\n// * data urls\n// * File/Blob objects\n// etc?\nexport async function fetchFile(url, options) {\n  url = resolvePath(url);\n  const func = isBrowser ? browserFetchFile : node.fetchFile;\n  return func(url, options);\n}\n\n// In a few cases (data URIs, node.js) \"files\" can be read synchronously\nexport function readFileSync(url, options = {}) {\n  url = resolvePath(url);\n  const func = isBrowser ? browserReadFileSync : node.readFileSync;\n  return func(url, options);\n}\n\n// DEPRECATED\n\n// Returns a promise that resolves to a readable stream\nexport async function createReadStream(url, options) {\n  url = resolvePath(url);\n  const func = isBrowser ? browserCreateReadStream : node.createReadStream;\n  return func(url, options);\n}\n","import {normalizeLoader} from './normalize-loader';\n\nconst EXT_PATTERN = /[^.]+$/;\n\n// Find a loader that works for extension/text\n// Search the loaders array argument for a loader that matches extension or text\nexport function autoDetectLoader(url = '', text, loaders) {\n  // Get extension\n  // TODO - Would be nice to support http://example.com/file.glb?parameter=1\n  // E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\n  const match = url.match(EXT_PATTERN);\n  if (match && match[0]) {\n    const extension = match[0];\n    const loader = findLoaderByExtension(loaders, extension);\n    if (loader) {\n      return loader;\n    }\n  }\n\n  const loader = findLoaderByExamingInitialData(loaders, text);\n  if (loader) {\n    return loader;\n  }\n\n  return null;\n}\n\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByExamingInitialData(loaders, text) {\n  for (const loader of loaders) {\n    if (loader.testText && loader.testText(text)) {\n      return loader;\n    }\n  }\n  return null;\n}\n","export default class NullLog {\n  log() {}\n  info() {}\n  warn() {}\n  error() {}\n}\n","import {toArrayBuffer} from '../javascript-utils/binary-utils';\n\nconst workerCache = new Map();\n\n/* global Worker, Blob, URL */\nfunction getWorker(workerSource) {\n  let workerURL = workerCache.get(workerSource);\n  if (!workerURL) {\n    const blob = new Blob([workerSource], {type: 'application/javascript'});\n    workerURL = URL.createObjectURL(blob);\n    workerCache.set(workerSource, workerURL);\n  }\n  return new Worker(workerURL);\n}\n\nexport default function parseWithWorker(workerSource, data, options) {\n  const worker = getWorker(workerSource);\n\n  options = removeNontransferableOptions(options);\n\n  const parse = (rawData, opts) =>\n    new Promise((resolve, reject) => {\n      worker.onmessage = evt => {\n        switch (evt.data.type) {\n          case 'done':\n            resolve(evt.data.result);\n            worker.terminate();\n            break;\n\n          case 'error':\n            reject(new Error(evt.data.message));\n            break;\n\n          default:\n        }\n      };\n\n      const arraybuffer = toArrayBuffer(rawData);\n      worker.postMessage({arraybuffer, opts}, [arraybuffer]);\n    });\n\n  return data ? parse(data, options) : parse;\n}\n\nfunction removeNontransferableOptions(options) {\n  options = Object.assign({}, options);\n  // log object contains functions which cannot be transferred\n  // TODO - decide how to handle logging on workers\n  if (options.log !== null) {\n    delete options.log;\n  }\n  return options;\n}\n","const isBoolean = x => typeof x === 'boolean';\nconst isFunction = x => typeof x === 'function';\nconst isObject = x => x !== null && typeof x === 'object';\n\nexport const isPromise = x => isObject(x) && isFunction(x.then);\n\nexport const isIterable = x => x && typeof x[Symbol.iterator] === 'function';\n\nexport const isAsyncIterable = x => x && typeof x[Symbol.asyncIterator] === 'function';\n\nexport const isIterator = x => isObject(x) && 'done' in x && 'value' in x;\n\nexport const isFetchResponse = x =>\n  (typeof window !== 'undefined' && x instanceof window.Response) ||\n  (x.arrayBuffer && x.json && x.body);\n\nexport const isWritableDOMStream = x => {\n  return isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);\n};\n\nexport const isReadableDOMStream = x => {\n  return (\n    isObject(x) &&\n    isFunction(x.tee) &&\n    isFunction(x.cancel) &&\n    isFunction(x.pipeTo) &&\n    isFunction(x.getReader)\n  );\n};\n\nexport const isWritableNodeStream = x => {\n  return isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);\n};\n\nexport const isReadableNodeStream = x => {\n  return isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);\n};\n\nexport const isReadableStream = x => isReadableDOMStream(x) || isReadableNodeStream(x);\n\nexport const isWritableStream = x => isWritableDOMStream(x) || isWritableNodeStream(x);\n","import {\n  isFetchResponse,\n  isReadableStream,\n  isAsyncIterable,\n  isIterable,\n  isIterator\n} from '../../javascript-utils/is-type';\nimport {getStreamIterator} from '../../javascript-utils/stream-utils';\nimport {TextDecoder} from '../../javascript-utils/text-encoding';\n\nconst ERR_DATA = 'Cannot convert supplied data type';\n\nexport function getUrlFromData(data) {\n  return isFetchResponse(data) ? data.url : null;\n}\n\nexport function getSizeFromData(data) {\n  return isFetchResponse(data) ? data.headers.get('Content-Length') : null;\n}\nexport function getArrayBufferOrStringFromDataSync(data, loader) {\n  if (loader.text && typeof data === 'string') {\n    return data;\n  }\n\n  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n    const arrayBuffer = data.buffer || data;\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(arrayBuffer);\n    }\n    return arrayBuffer;\n  }\n\n  throw new Error(ERR_DATA);\n}\n\n// Convert async iterator to a promise\nexport async function getArrayBufferOrStringFromData(data, loader) {\n  // Resolve any promise\n  data = await data;\n\n  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n  if (typeof data === 'string' || isArrayBuffer) {\n    return getArrayBufferOrStringFromDataSync(data, loader);\n  }\n\n  if (isFetchResponse(data)) {\n    return loader.binary ? await data.arrayBuffer() : data.text();\n  }\n\n  // if (isIterable(data) || isAsyncIterable(data)) {\n  // }\n\n  // Assume arrayBuffer iterator - attempt to concatenate\n  // return concatenateAsyncIterator(data);\n\n  throw new Error(ERR_DATA);\n}\n\nexport async function getAsyncIteratorFromData(data, loader) {\n  if (isIterator(data)) {\n    return data;\n  }\n\n  if (isFetchResponse(data)) {\n    return getStreamIterator(data.body);\n  }\n\n  if (isReadableStream(data)) {\n    return getStreamIterator(data);\n  }\n\n  if (isAsyncIterable(data)) {\n    return data[Symbol.asyncIterator]();\n  }\n\n  return getIteratorFromData(data, loader);\n}\n\nexport async function getIteratorFromData(data, loader) {\n  // generate an iterator that emits a single chunk\n  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n    return (function* oneChunk() {\n      yield data.buffer || data;\n    })();\n  }\n\n  if (isIterator(data)) {\n    return data;\n  }\n\n  if (isIterable(data)) {\n    return data[Symbol.iterator]();\n  }\n\n  throw new Error(ERR_DATA);\n}\n","import assert from '../utils/assert';\nimport parseWithWorker from './parse-with-worker';\nimport {\n  getArrayBufferOrStringFromDataSync,\n  getArrayBufferOrStringFromData,\n  getAsyncIteratorFromData,\n  getIteratorFromData,\n  // getLengthFromData,\n  getUrlFromData\n} from './loader-utils/get-data';\n\n// TODO: support progress and abort\n// TODO: support moving loading to worker\n// TODO - should accept loader.parseAsyncIterator and concatenate.\nexport async function parseWithLoader(data, loader, options = {}, url) {\n  url = url || getUrlFromData(data);\n  data = await getArrayBufferOrStringFromData(data, loader);\n\n  // First check for synchronous text parser, wrap results in promises\n  if (loader.parseTextSync && typeof data === 'string') {\n    options.dataType = 'text';\n    return loader.parseTextSync(data, options, url, loader);\n  }\n\n  // Now check for synchronous binary data parser, wrap results in promises\n  if (loader.parseSync) {\n    return loader.parseSync(data, options, url, loader);\n  }\n\n  // Check for asynchronous parser\n  if (loader.parse) {\n    return await loader.parse(data, options, url, loader);\n  }\n\n  if (loader.worker) {\n    return await parseWithWorker(loader.worker, data, options);\n  }\n\n  // TBD - If asynchronous parser not available, return null\n  // => This loader does not work on loaded data and only supports `loadAndParseAsync`\n  return assert(false);\n}\n\n// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator\nexport function parseWithLoaderSync(data, loader, options = {}, url) {\n  data = getArrayBufferOrStringFromDataSync(data, loader);\n\n  if (loader.parseTextSync && typeof data === 'string') {\n    return loader.parseTextSync(data, options, url, loader);\n  }\n\n  if (loader.parseSync) {\n    return loader.parseSync(data, options, url, loader);\n  }\n\n  // TBD - If synchronous parser not available, return null\n  // new Error(`Could not parse ${url || 'data'} using ${loader.name} loader`);\n  return assert(false);\n}\n\nexport async function parseWithLoaderInBatches(data, loader, options = {}, url) {\n  // Create async iterator adapter for data, and concatenate result\n  if (loader.parseInBatches) {\n    const inputIterator = await getAsyncIteratorFromData(data);\n    const outputIterator = loader.parseInBatches(inputIterator, options, url, loader);\n    return outputIterator;\n  }\n\n  // TODO - update after test cases have been fixed\n  return null;\n}\n\nexport async function parseWithLoaderInBatchesSync(data, loader, options = {}, url) {\n  // Create async iterator adapter for data, and concatenate result\n  if (loader.parseInBatchesSync) {\n    const inputIterator = getIteratorFromData(data);\n    const outputIterator = loader.parseInBatchesSync(inputIterator, options, url, loader, url);\n    return outputIterator;\n  }\n\n  return assert(false);\n}\n","import {autoDetectLoader} from './loader-utils/auto-detect-loader';\nimport {normalizeLoader, isLoaderObject} from './loader-utils/normalize-loader';\nimport NullLog from './loader-utils/null-log';\nimport {getRegisteredLoaders} from './register-loaders';\nimport {parseWithLoader, parseWithLoaderInBatches, parseWithLoaderSync} from './parse-with-loader';\n\nexport async function parse(data, loaders, options, url) {\n  // Signature: parse(data, options, url)\n  // Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    url = options;\n    options = loaders;\n    loaders = null;\n  }\n\n  loaders = loaders || getRegisteredLoaders();\n  const loader = Array.isArray(loaders) ? autoDetectLoader(url, data, loaders) : loaders;\n  if (!loader) {\n    // no loader available\n    // TODO: throw error?\n    return null;\n  }\n\n  normalizeLoader(loader);\n\n  // Normalize options\n  options = mergeLoaderAndUserOptions(options, loader);\n\n  return await parseWithLoader(data, loader, options, url);\n}\n\nexport function parseSync(data, loaders, options, url) {\n  // Signature: parseSync(data, options, url)\n  // Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    url = options;\n    options = loaders;\n    loaders = null;\n  }\n\n  // Choose loader and normalize it\n  loaders = loaders || getRegisteredLoaders();\n  const loader = Array.isArray(loaders) ? autoDetectLoader(url, data, loaders) : loaders;\n  normalizeLoader(loader);\n\n  // Normalize options\n  options = mergeLoaderAndUserOptions(options, loader);\n\n  return parseWithLoaderSync(data, loader, options, url);\n}\n\nexport async function parseInBatches(data, loaders, options, url) {\n  // Signature: parseInBatches(data, options, url)\n  // Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    url = options;\n    options = loaders;\n    loaders = null;\n  }\n\n  // Choose loader and normalize it\n  loaders = loaders || getRegisteredLoaders();\n  const loader = Array.isArray(loaders) ? autoDetectLoader(url, null, loaders) : loaders;\n  normalizeLoader(loader);\n\n  // Normalize options\n  options = mergeLoaderAndUserOptions(options, loader);\n\n  return parseWithLoaderInBatches(data, loader, options, url);\n}\n\nexport async function parseInBatchesSync(data, loaders, options, url) {\n  // Signature: parseInBatchesSync(data, options, url)\n  // Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    url = options;\n    options = loaders;\n    loaders = null;\n  }\n\n  // Choose loader and normalize it\n  loaders = loaders || getRegisteredLoaders();\n  const loader = Array.isArray(loaders) ? autoDetectLoader(url, null, loaders) : loaders;\n  normalizeLoader(loader);\n\n  // Normalize options\n  options = mergeLoaderAndUserOptions(options, loader);\n\n  return parseWithLoaderInBatches(data, loader, options, url);\n}\n\nfunction mergeLoaderAndUserOptions(options, loader) {\n  // TODO - explain why this optionb is needed for parsing\n  options = Object.assign({}, loader.DEFAULT_OPTIONS, loader.options, options, {\n    dataType: 'arraybuffer'\n  });\n\n  // LOGGING\n\n  // options.log can be set to `null` to defeat logging\n  if (options.log === null) {\n    options.log = new NullLog();\n  }\n  // log defaults to console\n  if (!('log' in options)) {\n    /* global console */\n    options.log = console;\n  }\n\n  return options;\n}\n","import {fetchFile} from './fetch/fetch-file';\nimport {isLoaderObject} from './loader-utils/normalize-loader';\nimport {autoDetectLoader} from './loader-utils/auto-detect-loader';\n\nimport {parse, parseInBatches} from './parse';\nimport {getRegisteredLoaders} from './register-loaders';\n\nexport async function loadInBatches(url, loaders, options) {\n  const response = await fetchFile(url, options);\n  return parseInBatches(response, loaders, options, url);\n}\n\nexport async function load(url, loaders, options) {\n  // Signature: load(url, options)\n  // Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    options = loaders;\n    loaders = null;\n  }\n\n  loaders = loaders || getRegisteredLoaders();\n  const loader = Array.isArray(loaders) ? autoDetectLoader(url, null, loaders) : loaders;\n\n  // Some loaders can not separate reading and parsing of data (e.g ImageLoader)\n  if (loader && loader.loadAndParse) {\n    return await loader.loadAndParse(url, options);\n  }\n\n  // at this point, data can be binary or text\n  let data = url;\n  if (typeof data === 'string') {\n    data = await fetchFile(url, options);\n  }\n  return parse(data, loaders, options, url);\n}\n"],"sourceRoot":""}