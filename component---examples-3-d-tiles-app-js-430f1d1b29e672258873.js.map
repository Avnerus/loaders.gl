{"version":3,"sources":["webpack:///../modules/3d-tiles/src/constants.js","webpack:///../modules/3d-tiles/src/parsers/helpers/parse-utils.js","webpack:///../modules/3d-tiles/src/math/gl-constants.js","webpack:///../modules/3d-tiles/src/math/gl-type.js","webpack:///../modules/3d-tiles/src/classes/tile-3d-feature-table.js","webpack:///../modules/3d-tiles/src/utils/assert.js","webpack:///../modules/3d-tiles/src/classes/helpers/tile-3d-accessor-utils.js","webpack:///../modules/3d-tiles/src/classes/tile-3d-batch-table-hierarchy.js","webpack:///../modules/3d-tiles/src/classes/tile-3d-batch-table.js","webpack:///../modules/3d-tiles/src/parsers/helpers/parse-3d-tile-header.js","webpack:///../modules/3d-tiles/src/parsers/helpers/parse-3d-tile-tables.js","webpack:///../modules/3d-tiles/src/parsers/parse-3d-tile-point-cloud.js","webpack:///../modules/3d-tiles/src/parsers/helpers/parse-3d-tile-gltf-view.js","webpack:///../modules/3d-tiles/src/parsers/parse-3d-tile.js","webpack:///../modules/3d-tiles/src/parsers/parse-3d-tile-composite.js","webpack:///../modules/3d-tiles/src/parsers/parse-3d-tile-batched-model.js","webpack:///../modules/3d-tiles/src/parsers/parse-3d-tile-instanced-model.js","webpack:///../modules/3d-tiles/src/tile-3d-loader.js","webpack:///../examples/3d-tiles/control-panel.js","webpack:///../examples/3d-tiles/app.js","webpack:///../examples/3d-tiles/file-drop.js","webpack:///./node_modules/core-js/modules/es6.object.keys.js","webpack:///./node_modules/core-js/modules/es6.typed.uint16-array.js","webpack:///./node_modules/core-js/modules/es6.number.constructor.js","webpack:///./node_modules/core-js/modules/es6.typed.int16-array.js","webpack:///./node_modules/core-js/modules/es6.typed.int8-array.js","webpack:///./node_modules/core-js/modules/es6.number.is-finite.js","webpack:///./node_modules/core-js/modules/_object-sap.js","webpack:///./node_modules/core-js/modules/es6.typed.int32-array.js","webpack:///./node_modules/core-js/modules/es6.typed.float64-array.js","webpack:///./node_modules/core-js/modules/es6.array.fill.js","webpack:///./node_modules/core-js/modules/_string-trim.js","webpack:///./node_modules/core-js/modules/_string-ws.js","webpack:///./node_modules/@babel/runtime/helpers/readOnlyError.js"],"names":["TILE3D_TYPE","COMPOSITE","POINT_CLOUD","BATCHED_3D_MODEL","INSTANCED_3D_MODEL","GEOMETRY","VECTOR","getStringFromArrayBuffer","arrayBuffer","byteOffset","byteLength","assert","textDecoder","text_encoding","typedArray","Uint8Array","gl_constants","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","DOUBLE","GL_TYPE_TO_ARRAY_TYPE","_GL_TYPE_TO_ARRAY_TYP","GL","Float64Array","Float32Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","NAME_TO_GL_TYPE","GLType","fromTypedArray","arrayOrType","glType","ArrayBuffer","Error","fromName","name","getArrayType","clamped","UNSIGNED_SHORT_5_6_5","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","ArrayType","getByteSize","BYTES_PER_ELEMENT","validate","Boolean","createTypedArray","buffer","length","undefined","Tile3DFeatureTable","featureTableJson","featureTableBinary","this","json","featuresLength","_cachedTypedArrays","getExtension","extensions","extensionName","hasProperty","propertyName","getGlobalProperty","componentType","componentLength","jsonValue","Number","_getTypedArrayFromBinary","getPropertyArray","_getTypedArrayFromArray","getProperty","featureId","i","result","cachedTypedArrays","count","assert_assert","condition","message","COMPONENTS_PER_ATTRIBUTE","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","UNPACKER","values","PACKER","x","defined","initializeHierarchy","batchTable","jsonHeader","binaryBody","hierarchy","legacyHierarchy","HIERARCHY","console","hierarchyJson","classId","binaryAccessor","parentIndexes","instancesLength","classes","classIds","parentCounts","parentIds","parentIdsLength","defaultValue","AttributeType","getBinaryAccessor","readOnlyError_default","classesLength","classInstancesLength","properties","instances","binaryProperties","getBinaryProperties","combine","classCounts","Array","fill","classIndexes","validateInstance","validateHierarchy","initializeHierarchyValues","traverseHierarchy","instanceIndex","endConditionCallback","visited","scratchVisited","Math","visitedMarker","marker","stack","scratchStack","parentCount","parentIndex","parentId","traverseHierarchyMultipleParents","hasParent","traverseHierarchySingleParent","clone","IGNORED_PROPERTY_FIELDS","extras","Tile3DBatchTableParser","binary","featureCount","options","_extensions","_properties","_binaryProperties","_initializeBinaryProperties","_hierarchy","memorySizeInBytes","isClass","_checkBatchId","batchId","className","instanceClass","isExactClass","getExactClassName","_hasPropertyInHierarchy","getPropertyNames","_results","results","propertyNames","Object","push","apply","_getPropertyNamesInHierarchy","binaryProperty","_getBinaryProperty","propertyValues","hierarchyProperty","_getHierarchyProperty","setProperty","_setBinaryProperty","value","_setHierarchyProperty","index","property","_initializeBinaryProperty","tile3DAccessor","type","accessor","size","unpacker","packer","createTypedArrayFromAccessor","componentCount","unpack","pack","_this","indexInClass","_this2","SIZEOF_UINT32","parse3DTileHeaderSync","tile","view","DataView","version","parse3DTileTablesHeaderSync","parse3DTileTablesSync","featureTableJsonByteLength","featureTableBinaryByteLength","BATCH_LENGTH","featureTableString","JSON","parse3DTileFeatureTable","batchTableJsonByteLength","batchTableBinaryByteLength","batchTableString","parse3DTileBatchTable","DECODING_STATE","NEEDS_DECODE","DECODING","READY","FAILED","parsePointCloud3DTile","featureTable","tile_3d_feature_table_Tile3DFeatureTable","pointsLength","positions","quantizedVolumeScale","quantizedVolumeOffset","parsePositions","colors","parseColors","normals","parseNormals","batchIds","batchFeatureLength","batchTableJson","batchTableBinary","tile_3d_batch_table_Tile3DBatchTableParser","parseBatch","dracoBuffer","dracoFeatureTableProperties","dracoBatchTableProperties","batchTableDraco","featureTableDraco","dracoByteOffset","dracoByteLength","assign","featureTableProperties","batchTableProperties","dequantizeInShader","parseDracoBuffer","extractPointCloud","parse3DTileGLTFViewSync","gltfByteLength","uint8Array","parse_3d_tile_parse3DTileSync","dataView","String","getMagicString","parse3DTileSync","subtile","parseComposite3DTileSync","parseBatchedModel3DTileSync","parseInstancedModel3DTileSync","parsePointCloud3DTileSync","tile_3d_loader","parseSync","url","loader","Container","styled","div","withConfig","displayName","componentId","DropDown","select","ControlPanel","_renderByCategories","_this$props","props","category","example","onChange","_this$props$data","data","categories","selectedValue","react_default","a","createElement","evt","categoryExample","map","c","categoryExamples","examples","key","label","keys","e","j","_renderDropped","droppedFile","render","PureComponent","MeshTile3DLoader","Tile3DLoader","registerLoaders","DATA_URI","INITIAL_VIEW_STATE","target","rotationX","rotationOrbit","orbitAxis","fov","minZoom","maxZoom","zoom","transitionInterpolator","esm","App","_PureComponent","call","state","viewState","_deckRef","_onLoad","bind","assertThisInitialized_default","_onViewStateChange","_rotateCamera","_getColor","_loadExample","_onSelectExample","componentDidMount","canvas","onDrop","deckCanvas","promise","file","setState","load","readPromise","Promise","resolve","reader","window","FileReader","ev","fetch","resp","_this2$state","_ref","transitionDuration","onTransitionEnd","selectedExample","path","_getDataRange","step","mins","POSITIVE_INFINITY","maxs","NEGATIVE_INFINITY","numOfPoints","getDataRange","_ref2","rgb565","r5","g6","b5","_this$state","_this$state$tile","isRGB565","constantRGBA","color","d","concat","_color","_renderLayers","_this$state$tile2","pointsCount","point_cloud_layer","id","coordinateSystem","COORDINATE_SYSTEM","IDENTITY","numInstances","instancePositions","getColor","getNormal","object","_ref3","opacity","pointSize","_this3","_ref4","_renderControlPanel","_this$state2","control_panel_ControlPanel","_this4","deckgl","ref","_","width","height","views","controller","onViewStateChange","layers","parameters","clearColor","renderToDOM","container","app_App","toObject","__webpack_require__","$keys","it","init","global","has","cof","inheritIfRequired","toPrimitive","fails","gOPN","f","gOPD","dP","$trim","trim","$Number","Base","proto","prototype","BROKEN_COF","TRIM","toNumber","argument","third","radix","maxCode","first","charCodeAt","NaN","code","digits","slice","l","parseInt","arguments","that","valueOf","split","constructor","$export","_isFinite","isFinite","S","core","module","exports","KEY","exec","fn","exp","F","P","spaces","space","ltrim","RegExp","rtrim","exporter","ALIAS","FORCE","string","TYPE","replace"],"mappings":"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","file":"component---examples-3-d-tiles-app-js-430f1d1b29e672258873.js","sourcesContent":["// TILE TYPES\n\nexport const TILE3D_TYPE = {\n  COMPOSITE: 'cmpt',\n  POINT_CLOUD: 'pnts',\n  BATCHED_3D_MODEL: 'b3dm',\n  INSTANCED_3D_MODEL: 'i3dm',\n  GEOMETRY: 'geom',\n  VECTOR: 'vect'\n};\n\nexport const MAGIC_ARRAY = {\n  BATCHED_MODEL: [98, 51, 100, 109],\n  INSTANCED_MODEL: [105, 51, 100, 109],\n  POINT_CLOUD: [112, 110, 116, 115],\n  COMPOSITE: [99, 109, 112, 116]\n};\n\n// TILE CONSTANTS\n\n// TODO - do we need this?\nexport const TILE3D_CONTENT_STATE = {\n  UNLOADED: 0, // Has never been requested\n  LOADING: 1, // Is waiting on a pending request\n  PROCESSING: 2, // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.\n  READY: 3, // Ready to render.\n  EXPIRED: 4, // Is expired and will be unloaded once new content is loaded.\n  FAILED: 5 // Request failed.\n};\nexport const TILE3D_OPTIMIZATION_HINT = {\n  NOT_COMPUTED: -1,\n  USE_OPTIMIZATION: 1,\n  SKIP_OPTIMIZATION: 0\n};\n\nexport const TILE3D_COLOR_BLEND_MODE = {\n  HIGHLIGHT: 0, // Multiplies the source color by the feature color.\n  REPLACE: 1, // Replaces the source color with the feature color.\n  MIX: 2 // Blends the source color and feature color together\n};\n\nexport const TILE3D_REFINE = {\n  ADD: 0, // Render tile and, if screen space error exceeded, also refine to its children.\n  REPLACE: 1 // Render tile or, if screen space error exceeded, refine to its descendants instead.\n};\n","import {TextDecoder, assert} from '@loaders.gl/core';\n\n// Decode the JSON binary array into clear text\nexport function getStringFromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  assert(arrayBuffer instanceof ArrayBuffer);\n  const textDecoder = new TextDecoder('utf8');\n  const typedArray = new Uint8Array(arrayBuffer, byteOffset, byteLength);\n  const string = textDecoder.decode(typedArray);\n  return string;\n}\n\n// Decode the JSON binary array into clear text\nexport function getStringFromTypedArray(typedArray) {\n  assert(ArrayBuffer.isView(typedArray));\n  const textDecoder = new TextDecoder('utf8');\n  const string = textDecoder.decode(typedArray);\n  return string;\n}\n\nexport function getMagicString(arrayBuffer, byteOffset = 0) {\n  const dataView = new DataView(arrayBuffer);\n  return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n","// SUBSET OF GL CONSTANTS - CAN BE USED DIRECTLY WITH WEBGL\n\nexport default {\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  DOUBLE: 5130\n};\n","import GL from './gl-constants';\n\nconst GL_TYPE_TO_ARRAY_TYPE = {\n  [GL.DOUBLE]: Float64Array,\n  [GL.FLOAT]: Float32Array,\n  [GL.UNSIGNED_SHORT]: Uint16Array,\n  [GL.UNSIGNED_INT]: Uint32Array,\n  [GL.UNSIGNED_BYTE]: Uint8Array,\n  [GL.BYTE]: Int8Array,\n  [GL.SHORT]: Int16Array,\n  [GL.INT]: Int32Array\n};\n\nconst NAME_TO_GL_TYPE = {\n  DOUBLE: GL.DOUBLE,\n  FLOAT: GL.FLOAT,\n  UNSIGNED_SHORT: GL.UNSIGNED_SHORT,\n  UNSIGNED_INT: GL.UNSIGNED_INT,\n  UNSIGNED_BYTE: GL.UNSIGNED_BYTE,\n  BYTE: GL.BYTE,\n  SHORT: GL.SHORT,\n  INT: GL.INT\n};\n\nconst ERR_TYPE_CONVERSION = 'Failed to convert GL type';\n\n// Converts TYPED ARRAYS to corresponding GL constant\n// Used to auto deduce gl parameter types\nexport default class GLType {\n  // Signature: fromTypedArray(new Uint8Array())\n  // Signature: fromTypedArray(Uint8Array)\n  static fromTypedArray(arrayOrType) {\n    // If typed array, look up constructor\n    arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n    for (const glType in GL_TYPE_TO_ARRAY_TYPE) {\n      const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n      if (ArrayType === arrayOrType) {\n        return glType;\n      }\n    }\n    throw new Error(ERR_TYPE_CONVERSION);\n  }\n\n  static fromName(name) {\n    const glType = NAME_TO_GL_TYPE[name];\n    if (!glType) {\n      throw new Error(ERR_TYPE_CONVERSION);\n    }\n    return glType;\n  }\n\n  // Converts GL constant to corresponding typed array type\n  // eslint-disable-next-line complexity\n  static getArrayType(glType, clamped = false) {\n    switch (glType) {\n      case GL.UNSIGNED_SHORT_5_6_5:\n      case GL.UNSIGNED_SHORT_4_4_4_4:\n      case GL.UNSIGNED_SHORT_5_5_5_1:\n        return Uint16Array;\n\n      default:\n        const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n        if (!ArrayType) {\n          throw new Error(ERR_TYPE_CONVERSION);\n        }\n        return ArrayType;\n    }\n  }\n\n  static getByteSize(glType) {\n    const ArrayType = GLType.getArrayType(glType);\n    return ArrayType.BYTES_PER_ELEMENT;\n  }\n\n  static validate(glType) {\n    return Boolean(GLType.getArrayType(glType));\n  }\n\n  static createTypedArray(glType, buffer, byteOffset = 0, length) {\n    if (length === undefined) {\n      length = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);\n    }\n\n    const ArrayType = GLType.getArrayType(glType);\n\n    return new ArrayType(buffer, byteOffset, length);\n  }\n}\n","import GL from '../math/gl-constants';\nimport GLType from '../math/gl-type';\n\n// Reference:\n// https://github.com/AnalyticalGraphicsInc/cesium/blob/1de96d087f0b17575eb1a3f736407b348c765d59/Source/Scene/Cesium3DTileFeatureTable.js\nexport default class Tile3DFeatureTable {\n  constructor(featureTableJson, featureTableBinary) {\n    this.json = featureTableJson;\n    this.buffer = featureTableBinary;\n    this.featuresLength = 0;\n    this._cachedTypedArrays = {};\n  }\n\n  getExtension(extensionName) {\n    return this.json.extensions && this.json.extensions[extensionName];\n  }\n\n  hasProperty(propertyName) {\n    return Boolean(this.json[propertyName]);\n  }\n\n  getGlobalProperty(propertyName, componentType = GL.UNSIGNED_INT, componentLength = 1) {\n    const jsonValue = this.json[propertyName];\n\n    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {\n      return this._getTypedArrayFromBinary(\n        propertyName,\n        componentType,\n        componentLength,\n        1,\n        jsonValue.byteOffset\n      );\n    }\n\n    return jsonValue;\n  }\n\n  getPropertyArray(propertyName, componentType, componentLength) {\n    const jsonValue = this.json[propertyName];\n\n    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {\n      if ('componentType' in jsonValue) {\n        componentType = GLType.fromName(jsonValue.componentType);\n      }\n      return this._getTypedArrayFromBinary(\n        propertyName,\n        componentType,\n        componentLength,\n        this.featuresLength,\n        jsonValue.byteOffset\n      );\n    }\n\n    return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);\n  }\n\n  getProperty(propertyName, componentType, componentLength, featureId, result) {\n    const jsonValue = this.json[propertyName];\n    if (!jsonValue) {\n      return jsonValue;\n    }\n\n    const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);\n\n    if (componentLength === 1) {\n      return typedArray[featureId];\n    }\n\n    for (let i = 0; i < componentLength; ++i) {\n      result[i] = typedArray[componentLength * featureId + i];\n    }\n\n    return result;\n  }\n\n  // HELPERS\n\n  _getTypedArrayFromBinary(propertyName, componentType, componentLength, count, byteOffset) {\n    const cachedTypedArrays = this._cachedTypedArrays;\n    let typedArray = cachedTypedArrays[propertyName];\n    if (!typedArray) {\n      typedArray = GLType.createTypedArray(\n        componentType,\n        this.buffer.buffer,\n        this.buffer.byteOffset + byteOffset,\n        count * componentLength\n      );\n      cachedTypedArrays[propertyName] = typedArray;\n    }\n    return typedArray;\n  }\n\n  _getTypedArrayFromArray(propertyName, componentType, array) {\n    const cachedTypedArrays = this._cachedTypedArrays;\n    let typedArray = cachedTypedArrays[propertyName];\n    if (!typedArray) {\n      typedArray = GLType.createTypedArray(componentType, array);\n      cachedTypedArrays[propertyName] = typedArray;\n    }\n    return typedArray;\n  }\n}\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || '3d-tile loader: assertion failed.');\n  }\n}\n","import GLType from '../../math/gl-type';\nimport assert from '../../utils/assert';\n\nconst COMPONENTS_PER_ATTRIBUTE = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\n// TODO - could just return typed array views...\n// prettier-ignore\nconst UNPACKER = {\n  SCALAR: (values, i) => values[i],\n  VEC2: (values, i) => [values[2 * i + 0], values[2 * i + 1]],\n  VEC3: (values, i) => [values[3 * i + 0], values[3 * i + 1], values[3 * i + 2]],\n  VEC4: (values, i) => [values[4 * i + 0], values[4 * i + 1], values[4 * i + 2], values[4 * i + 3]],\n  // TODO: check column major\n  MAT2: (values, i) => [\n    values[4 * i + 0], values[4 * i + 1],\n    values[4 * i + 2], values[4 * i + 3]\n  ],\n  MAT3: (values, i) => [\n    values[9 * i + 0], values[9 * i + 1], values[9 * i + 2],\n    values[9 * i + 3], values[9 * i + 4], values[9 * i + 5],\n    values[9 * i + 6], values[9 * i + 7], values[9 * i + 8]\n  ],\n  MAT4: (values, i) => [\n    values[16 * i + 0], values[16 * i + 1], values[16 * i + 2], values[16 * i + 3],\n    values[16 * i + 4], values[16 * i + 5], values[16 * i + 6], values[16 * i + 7],\n    values[16 * i + 8], values[16 * i + 9], values[16 * i + 10], values[16 * i + 11],\n    values[16 * i + 12], values[16 * i + 13], values[16 * i + 14], values[16 * i + 15]\n  ]\n};\n\nconst PACKER = {\n  SCALAR: (x, values, i) => {\n    values[i] = x;\n  },\n  VEC2: (x, values, i) => {\n    values[2 * i + 0] = x[0];\n    values[2 * i + 1] = x[1];\n  },\n  VEC3: (x, values, i) => {\n    values[3 * i + 0] = x[0];\n    values[3 * i + 1] = x[1];\n    values[3 * i + 2] = x[2];\n  },\n  VEC4: (x, values, i) => {\n    values[4 * i + 0] = x[0];\n    values[4 * i + 1] = x[1];\n    values[4 * i + 2] = x[2];\n    values[4 * i + 3] = x[3];\n  },\n  // TODO: check column major correctness\n  MAT2: (x, values, i) => {\n    values[4 * i + 0] = x[0];\n    values[4 * i + 1] = x[1];\n    values[4 * i + 2] = x[2];\n    values[4 * i + 3] = x[3];\n  },\n  MAT3: (x, values, i) => {\n    values[9 * i + 0] = x[0];\n    values[9 * i + 1] = x[1];\n    values[9 * i + 2] = x[2];\n    values[9 * i + 3] = x[3];\n    values[9 * i + 4] = x[4];\n    values[9 * i + 5] = x[5];\n    values[9 * i + 6] = x[6];\n    values[9 * i + 7] = x[7];\n    values[9 * i + 8] = x[8];\n    values[9 * i + 9] = x[9];\n  },\n  MAT4: (x, values, i) => {\n    values[16 * i + 0] = x[0];\n    values[16 * i + 1] = x[1];\n    values[16 * i + 2] = x[2];\n    values[16 * i + 3] = x[3];\n    values[16 * i + 4] = x[4];\n    values[16 * i + 5] = x[5];\n    values[16 * i + 6] = x[6];\n    values[16 * i + 7] = x[7];\n    values[16 * i + 8] = x[8];\n    values[16 * i + 9] = x[9];\n    values[16 * i + 10] = x[10];\n    values[16 * i + 11] = x[11];\n    values[16 * i + 12] = x[12];\n    values[16 * i + 13] = x[13];\n    values[16 * i + 14] = x[14];\n    values[16 * i + 15] = x[15];\n  }\n};\n\nexport function createTypedArrayFromAccessor(tile3DAccessor, buffer, byteOffset, length) {\n  const {componentType} = tile3DAccessor;\n  assert(tile3DAccessor.componentType);\n  const type = typeof componentType === 'string' ? GLType.fromName(componentType) : componentType;\n  const size = COMPONENTS_PER_ATTRIBUTE[tile3DAccessor.type];\n  const unpacker = UNPACKER[tile3DAccessor.type];\n  const packer = PACKER[tile3DAccessor.type];\n\n  byteOffset += tile3DAccessor.byteOffset;\n  const values = GLType.createTypedArray(type, buffer, byteOffset, size * length);\n\n  return {\n    values,\n    type,\n    size,\n    unpacker,\n    packer\n  };\n}\n","// TODO - Finish hierarchy suypport: this file is only half ported\n/* eslint-disable */\nconst defined = x => x !== undefined;\n\nexport function initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n  if (!jsonHeader) {\n    return null;\n  }\n\n  let hierarchy = batchTable.getExtension('3DTILES_batch_table_hierarchy');\n\n  const legacyHierarchy = jsonHeader.HIERARCHY;\n  if (legacyHierarchy) {\n    // eslint-disable-next-line\n    console.warn('3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.');\n    jsonHeader.extensions = jsonHeader.extensions || {};\n    jsonHeader.extensions['3DTILES_batch_table_hierarchy'] = legacyHierarchy;\n    hierarchy = legacyHierarchy;\n  }\n\n  if (!hierarchy) {\n    return null;\n  }\n\n  return initializeHierarchyValues(hierarchy, binaryBody);\n}\n\n// eslint-disable-next-line max-statements\nfunction initializeHierarchyValues(hierarchyJson, binaryBody) {\n  let i;\n  let classId;\n  let binaryAccessor;\n\n  const instancesLength = hierarchyJson.instancesLength;\n  const classes = hierarchyJson.classes;\n  const classIds = hierarchyJson.classIds;\n  const parentCounts = hierarchyJson.parentCounts;\n  const parentIds = hierarchyJson.parentIds;\n  const parentIdsLength = instancesLength;\n\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + classIds.byteOffset,\n      instancesLength\n    );\n  }\n\n  let parentIndexes;\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(\n        binaryBody.buffer,\n        binaryBody.byteOffset + parentCounts.byteOffset,\n        instancesLength\n      );\n    }\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n  }\n\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + parentIds.byteOffset,\n      parentIdsLength\n    );\n  }\n\n  const classesLength = classes.length;\n  for (i = 0; i < classesLength; ++i) {\n    const classInstancesLength = classes[i].length;\n    const properties = classes[i].instances;\n    const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n\n  const classCounts = new Array(classesLength).fill(0);\n  const classIndexes = new Uint16Array(instancesLength);\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n\n  const hierarchy = {\n    classes,\n    classIds,\n    classIndexes,\n    parentCounts,\n    parentIndexes,\n    parentIds\n  };\n\n  validateHierarchy(hierarchy);\n\n  return hierarchy;\n}\n\n// HELPER CODE\n\n// Traverse over the hierarchy and process each instance with the endConditionCallback.\n// When the endConditionCallback returns a value, the traversal stops and that value is returned.\nexport function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  if (!hierarchy) {\n    return;\n  }\n\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  if (parentIds) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  }\n  if (parentCounts > 0) {\n    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);\n  }\n  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);\n}\n\n// eslint-disable-next-line max-statements\nfunction traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {\n  const classIds = hierarchy.classIds;\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const instancesLength = classIds.length;\n\n  // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n  // Use a marker value to indicate that an instance has been visited, which increments with each run.\n  // This is more efficient than clearing the visited array every time.\n  const visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  const visitedMarker = ++marker;\n\n  const stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n    if (visited[instanceIndex] === visitedMarker) {\n      // This instance has already been visited, stop traversal\n      continue;\n    }\n    visited[instanceIndex] = visitedMarker;\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentCount = parentCounts[instanceIndex];\n    const parentIndex = parentIndexes[instanceIndex];\n    for (let i = 0; i < parentCount; ++i) {\n      const parentId = parentIds[parentIndex + i];\n      // Stop the traversal when the instance has no parent (its parentId equals itself)\n      // else add the parent to the stack to continue the traversal.\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {\n  let hasParent = true;\n  while (hasParent) {\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentId = hierarchy.parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n  throw new Error('traverseHierarchySingleParent');\n}\n\n// DEBUG CODE\n\nfunction validateHierarchy(hierarchy) {\n  const scratchValidateStack = [];\n\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n\n  for (let i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\n\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n\n  if (!defined(parentIds)) {\n    // No need to validate if there are no parents\n    return;\n  }\n\n  assert(\n    instanceIndex < instancesLength,\n    `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`\n  );\n  assert(\n    stack.indexOf(instanceIndex) === -1,\n    'Circular dependency detected in the batch table hierarchy.'\n  );\n\n  stack.push(instanceIndex);\n  const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  const parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;\n  for (let i = 0; i < parentCount; ++i) {\n    const parentId = parentIds[parentIndex + i];\n    // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n  stack.pop(instanceIndex);\n}\n","// import {GL} from '../constants';\nimport assert from '../utils/assert';\nimport {createTypedArrayFromAccessor} from './helpers/tile-3d-accessor-utils';\nimport {initializeHierarchy, traverseHierarchy} from './tile-3d-batch-table-hierarchy';\n\nconst defined = x => x !== undefined;\nconst clone = x => x;\n\n// These top level fields in the batch table json are not properties\nconst IGNORED_PROPERTY_FIELDS = {\n  HIERARCHY: true, // Deprecated HIERARCHY property\n  extensions: true,\n  extras: true\n};\n\n// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\nexport default class Tile3DBatchTableParser {\n  constructor(json, binary, featureCount, options = {}) {\n    assert(featureCount >= 0);\n    this.json = json || {};\n    this.binary = binary;\n    this.featureCount = featureCount;\n\n    this._extensions = (this.json && this.json.extensions) || {};\n\n    // Copy all top-level property fields from the json object, ignoring special fields\n    this._properties = {};\n    for (const propertyName in this.json) {\n      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {\n        this._properties[propertyName] = this.json[propertyName];\n      }\n    }\n\n    this._binaryProperties = this._initializeBinaryProperties();\n\n    // TODO: hierarchy support is only partially implemented and not tested\n    if (options['3DTILES_batch_table_hierarchy']) {\n      this._hierarchy = initializeHierarchy(this, this.json, this.binary);\n    }\n  }\n\n  getExtension(extensionName) {\n    return this.json && this.json.extensions && this.json.extensions[extensionName];\n  }\n\n  memorySizeInBytes() {\n    return 0;\n  }\n\n  isClass(batchId, className) {\n    this._checkBatchId(batchId);\n    assert(typeof className === 'string', className);\n\n    // extension: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      // PERFORMANCE_IDEA : cache results in the ancestor classes\n      //   to speed up this check if this area becomes a hotspot\n      // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n        const classId = hierarchy.classIds[instanceIndex];\n        const instanceClass = hierarchy.classes[classId];\n        return instanceClass.name === className;\n      });\n      return defined(result);\n    }\n\n    return false;\n  }\n\n  isExactClass(batchId, className) {\n    assert(typeof className === 'string', className);\n\n    return this.getExactClassName(batchId) === className;\n  }\n\n  getExactClassName(batchId) {\n    this._checkBatchId(batchId);\n\n    // extension: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      const classId = this._hierarchy.classIds[batchId];\n      const instanceClass = this._hierarchy.classes[classId];\n      return instanceClass.name;\n    }\n\n    return undefined;\n  }\n\n  hasProperty(batchId, name) {\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    return defined(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);\n  }\n\n  getPropertyNames(batchId, results) {\n    this._checkBatchId(batchId);\n\n    results = defined(results) ? results : [];\n    results.length = 0;\n\n    const propertyNames = Object.keys(this._properties);\n    results.push(...propertyNames);\n\n    if (this._hierarchy) {\n      this._getPropertyNamesInHierarchy(batchId, results);\n    }\n\n    return results;\n  }\n\n  getProperty(batchId, name) {\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n      if (defined(binaryProperty)) {\n        return this._getBinaryProperty(binaryProperty, batchId);\n      }\n    }\n\n    const propertyValues = this._properties[name];\n    if (defined(propertyValues)) {\n      return clone(propertyValues[batchId], true);\n    }\n\n    // EXTENSION: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      const hierarchyProperty = this._getHierarchyProperty(batchId, name);\n      if (defined(hierarchyProperty)) {\n        return hierarchyProperty;\n      }\n    }\n\n    return undefined;\n  }\n\n  setProperty(batchId, name, value) {\n    const featureCount = this.featureCount;\n\n    this._checkBatchId(batchId, featureCount);\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n      if (binaryProperty) {\n        this._setBinaryProperty(binaryProperty, batchId, value);\n        return;\n      }\n    }\n\n    // EXTENSION: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      if (this._setHierarchyProperty(this, batchId, name, value)) {\n        return;\n      }\n    }\n\n    let propertyValues = this._properties[name];\n    if (!defined(propertyValues)) {\n      // Property does not exist. Create it.\n      this._properties[name] = new Array(featureCount);\n      propertyValues = this._properties[name];\n    }\n\n    propertyValues[batchId] = clone(value, true);\n  }\n\n  // PRIVATE METHODS\n\n  _checkBatchId(batchId) {\n    const valid = batchId >= 0 && batchId < this.featureCount;\n    if (!valid) {\n      throw new Error(`batchId not in range [0, featureCount - 1].`);\n    }\n  }\n\n  _getBinaryProperty(binaryProperty, index) {\n    return binaryProperty.unpack(binaryProperty.typedArray, index);\n  }\n\n  _setBinaryProperty(binaryProperty, index, value) {\n    binaryProperty.pack(value, binaryProperty.typedArray, index);\n  }\n\n  _initializeBinaryProperties() {\n    let binaryProperties = null;\n    for (const name in this._properties) {\n      const property = this._properties[name];\n      const binaryProperty = this._initializeBinaryProperty(name, property);\n      // Store any information needed to access the binary data, including the typed array,\n      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n      if (binaryProperty) {\n        binaryProperties = binaryProperties || {};\n        binaryProperties[name] = binaryProperty;\n      }\n    }\n    return binaryProperties;\n  }\n\n  _initializeBinaryProperty(name, property) {\n    if ('byteOffset' in property) {\n      // This is a binary property\n      const tile3DAccessor = property;\n\n      assert(this.binary, `Property ${name} requires a batch table binary.`);\n      assert(tile3DAccessor.type, `Property ${name} requires a type.`);\n\n      const accessor = createTypedArrayFromAccessor(\n        tile3DAccessor,\n        this.binary.buffer,\n        this.binary.byteOffset | 0,\n        this.featureCount\n      );\n\n      // Store any information needed to access the binary data, including the typed array,\n      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n      return {\n        typedArray: accessor.values,\n        componentCount: accessor.size,\n        unpack: accessor.unpacker,\n        pack: accessor.packer\n      };\n    }\n\n    return null;\n  }\n\n  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy\n\n  _hasPropertyInHierarchy(batchId, name) {\n    if (!this._hierarchy) {\n      return false;\n    }\n\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      return defined(instances[name]);\n    });\n\n    return defined(result);\n  }\n\n  _getPropertyNamesInHierarchy(batchId, results) {\n    traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      for (const name in instances) {\n        if (instances.hasOwnProperty(name)) {\n          if (results.indexOf(name) === -1) {\n            results.push(name);\n          }\n        }\n      }\n    });\n  }\n\n  _getHierarchyProperty(batchId, name) {\n    return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n      if (defined(propertyValues)) {\n        if (defined(propertyValues.typedArray)) {\n          return this._getBinaryProperty(propertyValues, indexInClass);\n        }\n        return clone(propertyValues[indexInClass], true);\n      }\n      return null;\n    });\n  }\n\n  _setHierarchyProperty(batchTable, batchId, name, value) {\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n      if (defined(propertyValues)) {\n        assert(instanceIndex === batchId, `Inherited property \"${name}\" is read-only.`);\n        if (defined(propertyValues.typedArray)) {\n          this._setBinaryProperty(propertyValues, indexInClass, value);\n        } else {\n          propertyValues[indexInClass] = clone(value, true);\n        }\n        return true;\n      }\n      return false;\n    });\n    return defined(result);\n  }\n}\n","const SIZEOF_UINT32 = 4;\n\n/* PARSE FIXED HEADER:\nPopulates\n  magic, // identifies type of tile\n  type, // String version of magic\n  version,\n  byteLength\n */\nexport function parse3DTileHeaderSync(tile, arrayBuffer, byteOffset = 0) {\n  const view = new DataView(arrayBuffer);\n\n  tile.magic = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  tile.version = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  tile.byteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  // TODO - move version check into each tile parser?\n  if (tile.version !== 1) {\n    throw new Error(`3D Tile Version ${tile.version} not supported`);\n  }\n\n  return byteOffset; // Indicates where the parsing ended\n}\n","import {getStringFromArrayBuffer} from './parse-utils';\n\nconst SIZEOF_UINT32 = 4;\n\n// eslint-disable-next-line max-statements\nexport function parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset) {\n  const view = new DataView(arrayBuffer);\n\n  tile.featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  tile.featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  tile.batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  tile.batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  return byteOffset;\n}\n\nexport function parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options) {\n  byteOffset = parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options);\n  return byteOffset;\n}\n\nfunction parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options) {\n  const {featureTableJsonByteLength, featureTableBinaryByteLength} = tile;\n\n  tile.featureTableJson = {\n    BATCH_LENGTH: 0\n  };\n\n  if (featureTableJsonByteLength > 0) {\n    const featureTableString = getStringFromArrayBuffer(\n      arrayBuffer,\n      byteOffset,\n      featureTableJsonByteLength\n    );\n    tile.featureTableJson = JSON.parse(featureTableString);\n  }\n  byteOffset += featureTableJsonByteLength;\n\n  tile.featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n  byteOffset += featureTableBinaryByteLength;\n\n  /*\n  const featureTable = parseFeatureTable(featureTableJson, featureTableBinary);\n\n  const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n  featureTable.featuresLength = batchLength;\n  */\n\n  return byteOffset;\n}\n\nfunction parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options) {\n  const {batchTableJsonByteLength, batchTableBinaryByteLength} = tile;\n\n  if (batchTableJsonByteLength > 0) {\n    const batchTableString = getStringFromArrayBuffer(\n      arrayBuffer,\n      byteOffset,\n      batchTableJsonByteLength\n    );\n    tile.batchTableJson = JSON.parse(batchTableString);\n    byteOffset += batchTableJsonByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      tile.batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);\n\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  return byteOffset;\n}\n","import GL from '../math/gl-constants';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\n\nconst DECODING_STATE = {\n  NEEDS_DECODE: 0,\n  DECODING: 1,\n  READY: 2,\n  FAILED: 3\n};\n\n// Reference code\n// https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Scene/PointCloud.js#L254\nexport default function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n\n  extractPointCloud(tile);\n\n  return byteOffset;\n}\n\n// eslint-disable-next-line max-statements, complexity\nfunction extractPointCloud(tile) {\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n\n  const pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n  tile.featuresLength = pointsLength;\n\n  featureTable.featuresLength = pointsLength;\n\n  if (!Number.isFinite(pointsLength)) {\n    throw new Error('POINTS_LENGTH must be defined');\n  }\n\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  // Initialize point cloud tile defaults\n  tile.positions = null;\n  tile.colors = null;\n  tile.normals = null;\n  tile.batchIds = null;\n  tile.isQuantized = false;\n  tile.isTranslucent = false;\n  tile.isRGB565 = false;\n  tile.isOctEncoded16P = false;\n\n  parsePositions(tile, featureTable);\n  parseColors(tile, featureTable);\n  parseNormals(tile, featureTable);\n\n  const batchTable = parseBatch(tile, featureTable);\n  parseDracoBuffer(tile, featureTable, batchTable);\n}\n\nfunction parsePositions(tile, featureTable) {\n  if (!tile.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      tile.positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n      tile.isQuantized = true;\n      tile.quantizedRange = (1 << 16) - 1;\n\n      tile.quantizedVolumeScale = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_SCALE',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeScale) {\n        throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n\n      tile.quantizedVolumeOffset = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_OFFSET',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeOffset) {\n        throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n    }\n  }\n\n  if (!tile.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n\nfunction parseColors(tile, featureTable) {\n  if (!tile.colors) {\n    if (featureTable.hasProperty('RGBA')) {\n      tile.colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      tile.colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasProperty('RGB565')) {\n      tile.colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n  }\n\n  if (featureTable.hasProperty('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n}\n\nfunction parseNormals(tile, featureTable) {\n  if (!tile.normals) {\n    if (featureTable.hasProperty('NORMAL')) {\n      tile.normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n      tile.normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n  }\n}\n\nfunction parseBatch(tile, featureTable) {\n  let batchTable = null;\n  if (featureTable.hasProperty('BATCH_ID')) {\n    tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n\n    if (tile.batchIds) {\n      const batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n      if (!batchFeatureLength) {\n        throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n      }\n      const {batchTableJson, batchTableBinary} = tile;\n      batchTable = new Tile3DBatchTable(batchTableJson, batchTableBinary, batchFeatureLength);\n    }\n  }\n\n  return batchTable;\n}\n\n// function parseStyles(tile, featureTable) {\n//   const batchTable = tile.batchTable;\n//   if (!tile.batchIds && tile.batchTableBinary) {\n//     tile.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n//       pointsLength,\n//       batchTableJson,\n//       batchTableBinary\n//     );\n//   }\n// }\n\nexport function parseDracoBuffer(tile, featureTable, batchTable) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n  const batchTableDraco = batchTable && batchTable.getExtension('3DTILES_draco_point_compression');\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n\n    tile.hasPositions = dracoFeatureTableProperties.POSITION;\n    tile.hasColors = dracoFeatureTableProperties.RGB || dracoFeatureTableProperties.RGBA;\n    tile.hasNormals = dracoFeatureTableProperties.NORMAL;\n    tile.hasBatchIds = dracoFeatureTableProperties.BATCH_ID;\n    tile.isTranslucent = dracoFeatureTableProperties.RGBA;\n  }\n\n  if (dracoBuffer) {\n    tile.draco = {\n      buffer: dracoBuffer,\n      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      dequantizeInShader: false\n    };\n\n    tile.decodingState = DECODING_STATE.NEEDS_DECODE;\n  }\n}\n\nexport function parseRGB565(rgb565) {\n  let r5 = rgb565 & 31;\n  let g6 = (rgb565 >> 5) & 63;\n  let b5 = (rgb565 >> 11) & 31;\n\n  r5 = Math.round((r5 * 255) / 32);\n  g6 = Math.round((g6 * 255) / 64);\n  b5 = Math.round((b5 * 255) / 32);\n\n  return [r5, g6, b5];\n}\n\n/*\n  const batchTable = new Tile3DBatchTable(tile);\n\n  // parseDracoBuffer(tile, featureTable, batchTable);\n\n  if (!tile.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n/*\n\n  if (!tile.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      tile.positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n\n  if (!tile.colors) {\n    if (featureTable.hasProperty('RGBA')) {\n      tile.colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      tile.colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasPropertry('RGB565')) {\n      tile.colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n  }\n\n  if (!tile.normals) {\n    if (featureTable.getPropertry('NORMAL')) {\n      tile.normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.getProperty('NORMAL_OCT16P')) {\n      tile.normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n  }\n\n  if (!tile.batchIds) {\n    if (featureTable.hasProperty('BATCH_ID')) {\n      tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n    }\n  }\n\n  if (!tile.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n\n  if (featureTable.getPropertry('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n\n  if (tile.batchIds) {\n    const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n    if (!defined(batchLength)) {\n      throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(batchLength, batchTableJson, batchTableBinary);\n    }\n  }\n\n  // If points are not batched and there are per-point properties, use these properties for styling purposes\n  var styleableProperties;\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    tile.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      pointsLength,\n      batchTableJson,\n      batchTableBinary\n    );\n  }\n\n  tile.draco = draco;\n}\n\n// Separate parsing and decoding of Draco\nexport function parseDracoBuffer(tile, featureTable, batchTable) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n\n  const batchTableDraco = batchTable.getExtension('3DTILES_draco_point_compression');\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !dracoByteOffset || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = arraySlice(\n      featureTableBinary,\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength\n    );\n    tile.hasPositions = dracoFeatureTableProperties.POSITION;\n    tile.hasColors = dracoFeatureTableProperties.RGB || dracoFeatureTableProperties.RGBA;\n    tile.hasNormals = dracoFeatureTableProperties.NORMAL;\n    tile.hasBatchIds = dracoFeatureTableProperties.BATCH_ID;\n    tile.isTranslucent = dracoFeatureTableProperties.RGBA;\n  }\n\n  if (dracoBuffer) {\n    tile.draco = {\n      buffer: dracoBuffer,\n      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      dequantizeInShader: false\n    };\n\n    tile.decodingState = DECODING_STATE.NEEDS_DECODE;\n  }\n}\n\n/*\nfunction decodeDraco(tile, context) {\n  if (tile.decodingState === DECODING_STATE.READY) {\n    return false;\n  }\n  if (tile.decodingState === DECODING_STATE.NEEDS_DECODE) {\n    var parsedContent = tile._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      tile.decodingState = DECODING_STATE.DECODING;\n      decodePromise.then(function(result) {\n        tile.decodingState = DECODING_STATE.READY;\n        var decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;\n        var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n        var decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;\n        var decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;\n        var decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;\n        var isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);\n        var isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n        if (isQuantizedDraco) {\n          // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n          var quantization = result.POSITION.data.quantization;\n          var range = quantization.range;\n          tile._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n          tile._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n          tile._quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n          tile._isQuantizedDraco = true;\n        }\n        if (isOctEncodedDraco) {\n          tile._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n          tile._isOctEncodedDraco = true;\n        }\n        var styleableProperties = parsedContent.styleableProperties;\n        var batchTableProperties = draco.batchTableProperties;\n        for (var name in batchTableProperties) {\n          if (batchTableProperties.hasOwnProperty(name)) {\n            var property = result[name];\n            if (!defined(styleableProperties)) {\n              styleableProperties = {};\n            }\n            styleableProperties[name] = {\n              typedArray : property.array,\n              componentCount : property.data.componentsPerAttribute\n            };\n          }\n        }\n        parsedContent.positions = defaultValue(decodedPositions, parsedContent.positions);\n        parsedContent.colors = defaultValue(defaultValue(decodedRgba, decodedRgb), parsedContent.colors);\n        parsedContent.normals = defaultValue(decodedNormals, parsedContent.normals);\n        parsedContent.batchIds = defaultValue(decodedBatchIds, parsedContent.batchIds);\n        parsedContent.styleableProperties = styleableProperties;\n      }).otherwise(function(error) {\n        tile.decodingState = DECODING_STATE.FAILED;\n        tile._readyPromise.reject(error);\n      });\n    }\n  }\n  return true;\n}\n*/\n","export function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset) {\n  // Assume glTF consumes rest of tile\n  const gltfByteLength = tile.byteOffset + tile.byteLength - byteOffset;\n  if (gltfByteLength === 0) {\n    throw new Error('glTF byte length must be greater than 0.');\n  }\n\n  if (byteOffset % 4 === 0) {\n    tile.gltfView = new Uint8Array(arrayBuffer, byteOffset, gltfByteLength);\n  } else {\n    // Create a copy of the glb so that it is 4-byte aligned\n    // eslint-disable-next-line\n    console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);\n    const uint8Array = new Uint8Array(arrayBuffer);\n    tile.gltfView = new Uint8Array(uint8Array.subarray(byteOffset, byteOffset + gltfByteLength));\n  }\n\n  // Entire tile is consumed\n  return tile.byteOffset + tile.byteLength;\n}\n","import {TILE3D_TYPE} from '../constants';\nimport {getMagicString} from './helpers/parse-utils';\n\nimport parsePointCloud3DTileSync from './parse-3d-tile-point-cloud';\nimport parseBatchedModel3DTileSync from './parse-3d-tile-batched-model';\nimport parseInstancedModel3DTileSync from './parse-3d-tile-instanced-model';\nimport parseComposite3DTileSync from './parse-3d-tile-composite';\n\n// Extracts\nexport default function parse3DTileSync(arrayBuffer, byteOffset = 0, options = {}, tile = {}) {\n  tile.byteOffset = byteOffset;\n  tile.type = getMagicString(arrayBuffer, byteOffset);\n\n  switch (tile.type) {\n    case TILE3D_TYPE.COMPOSITE:\n      // Note: We pass this function as argument so that embedded tiles can be parsed recursively\n      parseComposite3DTileSync(tile, arrayBuffer, byteOffset, options, parse3DTileSync);\n      break;\n\n    case TILE3D_TYPE.BATCHED_3D_MODEL:\n      parseBatchedModel3DTileSync(tile, arrayBuffer, byteOffset, options);\n      break;\n\n    case TILE3D_TYPE.INSTANCED_3D_MODEL:\n      parseInstancedModel3DTileSync(tile, arrayBuffer, byteOffset, options);\n      break;\n\n    case TILE3D_TYPE.POINT_CLOUD:\n      parsePointCloud3DTileSync(tile, arrayBuffer, byteOffset, options);\n      break;\n\n    default:\n      throw new Error(`3DTileLoader: unknown type ${tile.type}`); // eslint-disable-line\n  }\n\n  return tile;\n}\n","import {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\n\n// Reference code:\n// https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Scene/Composite3DTileContent.js#L182\nexport default function parseComposite3DTileSync(\n  tile,\n  arrayBuffer,\n  byteOffset,\n  options,\n  parse3DTileSync\n) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset, options);\n\n  const view = new DataView(arrayBuffer);\n\n  // Extract number of tiles\n  tile.tilesLength = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n\n  // extract each tile from the byte stream\n  tile.tiles = [];\n  while (tile.tiles.length < tile.tilesLength && tile.byteLength - byteOffset > 12) {\n    const subtile = {};\n    tile.tiles.push(subtile);\n    byteOffset = parse3DTileSync(arrayBuffer, byteOffset, options, subtile);\n    // TODO - do we need to add any padding in between tiles?\n  }\n\n  return byteOffset;\n}\n","import GL from '../math/gl-constants';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\n// import Tile3DBatchTable from '../classes/tile-3d-batch-table';\n\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\nimport {parse3DTileGLTFViewSync} from './helpers/parse-3d-tile-gltf-view';\n\n// eslint-disable-next-line max-statements\nexport default function parseBatchedModel3DTileSync(tile, arrayBuffer, byteOffset, options) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset, options);\n\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n\n  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  return byteOffset;\n}\n","import GL from '../math/gl-constants';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\n// import Tile3DBatchTable from '../classes/tile-3d-batch-table';\n\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\nimport {parse3DTileGLTFViewSync} from './helpers/parse-3d-tile-gltf-view';\n\n// Reference code:\n// https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Scene/Instanced3DModel3DTileContent.js#L190\nexport default function parseInstancedModel3DTileSync(tile, arrayBuffer, byteOffset, options) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset, options);\n  if (tile.version !== 1) {\n    throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);\n  }\n\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset, options);\n\n  const view = new DataView(arrayBuffer);\n\n  tile.gltfFormat = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n\n  // PARSE FEATURE TABLE\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n\n  byteOffset = parse3DTileGLTFViewSync(tile, byteOffset);\n\n  // TODO - Is the feature table sometimes optional or can check be moved into table header parser?\n  if (tile.featureTableJsonByteLength === 0) {\n    throw new Error('i3dm parser: featureTableJsonByteLength is zero.');\n  }\n\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n\n  const instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');\n  featureTable.featuresLength = instancesLength;\n\n  if (!Number.isFinite(instancesLength)) {\n    throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');\n  }\n\n  /*\n  const batchTable = new Tile3DBatchTable(tile, instancesLength);\n\n  switch (tile.gltfFormat) {\n    case 0:\n      const gltfUrl = getStringFromTypedArray(tile.gltfView);\n      // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.\n      // This removes all white space and null characters from the end of the string.\n      tile.url = gltfUrl.replace(/[\\s\\0]+$/, '');\n      throw new Error('i3dm: glTF format 0 (uri) not yet implemented');\n      break;\n    case 1:\n      tile.gltf = gltfView;\n      break;\n    default:\n      throw new Error(`i3dm: glTF format ${tile.gltfFormat}: Must be 0 (uri) or 1 (embedded)`);\n  }\n  */\n\n  tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  // extractInstancedAttributes(tile, featureTable);\n\n  return byteOffset;\n}\n\n/*\n// eslint-disable-next-line max-statements, complexity\nfunction extractInstancedAttributes(tile, featureTable, batchTable) {\n  // Create model instance collection\n  // const collectionOptions = {\n  //   instances: new Array(instancesLength),\n  //   batchTable: tile._batchTable,\n  //   cull: false, // Already culled by 3D Tiles\n  //   url: undefined,\n  //   requestType: RequestType.TILES3D,\n  //   gltf: undefined,\n  //   basePath: undefined,\n  //   incrementallyLoadTextures: false,\n  //   upAxis: tileset._gltfUpAxis,\n  //   forwardAxis: Axis.X,\n  //   opaquePass: Pass.CESIUM_3D_TILE, // Draw opaque portions during the 3D Tiles pass\n  //   pickIdLoaded: getPickIdCallback(tile),\n  //   imageBasedLightingFactor: tileset.imageBasedLightingFactor,\n  //   lightColor: tileset.lightColor,\n  //   luminanceAtZenith: tileset.luminanceAtZenith,\n  //   sphericalHarmonicCoefficients: tileset.sphericalHarmonicCoefficients,\n  //   specularEnvironmentMaps: tileset.specularEnvironmentMaps\n  // };\n\n  const instances = collectionOptions.instances;\n  const instancePosition = new Cartesian3();\n  const instancePositionArray = new Array(3);\n  const instanceNormalRight = new Cartesian3();\n  const instanceNormalUp = new Cartesian3();\n  const instanceNormalForward = new Cartesian3();\n  const instanceRotation = new Matrix3();\n  const instanceQuaternion = new Quaternion();\n  const instanceScale = new Cartesian3();\n  const instanceTranslationRotationScale = new TranslationRotationScale();\n  const instanceTransform = new Matrix4();\n  const scratch1 = new Array();\n  const scratch2 = new Array();\n\n  for (const i = 0; i < instancesLength; i++) {\n    // Get the instance position\n    if (featureTable.hasProperty('POSITION')) {\n      tile.position = featureTable.getProperty('POSITION', GL.FLOAT, 3, i, scratch1);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      tile.position = instancePositionArray;\n      tile.positionQuantized = featureTable.getProperty(\n        'POSITION_QUANTIZED',\n        GL.UNSIGNED_SHORT,\n        3,\n        scratch1\n      );\n\n      tile.quantizedVolumeOffset = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_OFFSET',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeOffset) {\n        throw new Error(\n          'i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.'\n        );\n      }\n\n      const quantizedVolumeScale = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_SCALE',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeScale) {\n        throw new Error(\n          'i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.'\n        );\n      }\n\n      for (const j = 0; j < 3; j++) {\n        position[j] =\n          (positionQuantized[j] / 65535.0) * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n      }\n    }\n\n    if (!tile.position) {\n      throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');\n    }\n\n    Cartesian3.unpack(position, 0, instancePosition);\n    if (defined(rtcCenter)) {\n      Cartesian3.add(instancePosition, rtcCenter, instancePosition);\n    }\n    instanceTranslationRotationScale.translation = instancePosition;\n\n    // Get the instance rotation\n    tile.normalUp = featureTable.getProperty('NORMAL_UP', GL.FLOAT, 3, i, scratch1);\n    tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', GL.FLOAT, 3, i, scratch2);\n\n    const hasCustomOrientation = false;\n    if (tile.normalUp) {\n      if (!tile.normalRight) {\n        throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');\n      }\n      // Cartesian3.unpack(normalUp, 0, instanceNormalUp);\n      // Cartesian3.unpack(normalRight, 0, instanceNormalRight);\n      tile.hasCustomOrientation = true;\n    } else {\n      tile.octNormalUp = featureTable.getProperty(\n        'NORMAL_UP_OCT32P',\n        GL.UNSIGNED_SHORT,\n        2,\n        scratch1\n      );\n      tile.octNormalRight = featureTable.getProperty(\n        'NORMAL_RIGHT_OCT32P',\n        GL.UNSIGNED_SHORT,\n        2,\n        scratch2\n      );\n\n      if (tile.octNormalUp) {\n        if (!tile.octNormalRight) {\n          throw new Error(\n            'i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P'\n          );\n        }\n\n        AttributeCompression.octDecodeInRange(\n          octNormalUp[0],\n          octNormalUp[1],\n          65535,\n          instanceNormalUp\n        );\n\n        AttributeCompression.octDecodeInRange(\n          octNormalRight[0],\n          octNormalRight[1],\n          65535,\n          instanceNormalRight\n        );\n\n        hasCustomOrientation = true;\n      } else if (eastNorthUp) {\n        Transforms.eastNorthUpToFixedFrame(instancePosition, Ellipsoid.WGS84, instanceTransform);\n        Matrix4.getRotation(instanceTransform, instanceRotation);\n      } else {\n        Matrix3.clone(Matrix3.IDENTITY, instanceRotation);\n      }\n    }\n\n    if (hasCustomOrientation) {\n      Cartesian3.cross(instanceNormalRight, instanceNormalUp, instanceNormalForward);\n      Cartesian3.normalize(instanceNormalForward, instanceNormalForward);\n      Matrix3.setColumn(instanceRotation, 0, instanceNormalRight, instanceRotation);\n      Matrix3.setColumn(instanceRotation, 1, instanceNormalUp, instanceRotation);\n      Matrix3.setColumn(instanceRotation, 2, instanceNormalForward, instanceRotation);\n    }\n\n    Quaternion.fromRotationMatrix(instanceRotation, instanceQuaternion);\n    instanceTranslationRotationScale.rotation = instanceQuaternion;\n\n    // Get the instance scale\n    instanceScale = Cartesian3.fromElements(1.0, 1.0, 1.0, instanceScale);\n    const scale = featureTable.getProperty('SCALE', GL.FLOAT, 1, i);\n    if (defined(scale)) {\n      Cartesian3.multiplyByScalar(instanceScale, scale, instanceScale);\n    }\n    const nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', GL.FLOAT, 3, i, scratch1);\n    if (defined(nonUniformScale)) {\n      instanceScale.x *= nonUniformScale[0];\n      instanceScale.y *= nonUniformScale[1];\n      instanceScale.z *= nonUniformScale[2];\n    }\n    instanceTranslationRotationScale.scale = instanceScale;\n\n    // Get the batchId\n    const batchId = featureTable.getProperty('BATCH_ID', GL.UNSIGNED_SHORT, 1, i);\n    if (!defined(batchId)) {\n      // If BATCH_ID semantic is undefined, batchId is just the instance number\n      batchId = i;\n    }\n\n    // Create the model matrix and the instance\n    Matrix4.fromTranslationRotationScale(instanceTranslationRotationScale, instanceTransform);\n    const modelMatrix = instanceTransform.clone();\n    instances[i] = {\n      modelMatrix: modelMatrix,\n      batchId: batchId\n    };\n  }\n\n  tile._modelInstanceCollection = new ModelInstanceCollection(collectionOptions);\n}\n*/\n","import parse3DTileSync from './parsers/parse-3d-tile';\n\n// Tile3DLoader\nexport default {\n  name: '3D Tiles',\n  extensions: ['cmpt', 'pnts', 'b3dm', 'i3dm'],\n  parseSync,\n  binary: true\n};\n\nfunction parseSync(arrayBuffer, options, url, loader) {\n  const byteOffset = 0;\n  return parse3DTileSync(arrayBuffer, byteOffset, options);\n}\n","import styled from 'styled-components';\nimport React, {PureComponent} from 'react';\n\nconst Container = styled.div`\n  display: flex;\n  flex-direction: column;\n  position: absolute;\n  top: 0;\n  right: 0;\n  max-width: 320px;\n  background: #fff;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n  padding: 12px 24px;\n  margin: 20px;\n  font-size: 13px;\n  line-height: 2;\n  outline: none;\n  z-index: 100;\n`;\n\nconst DropDown = styled.select`\n  margin-bottom: 6px;\n`;\n\nexport default class ControlPanel extends PureComponent {\n  _renderByCategories() {\n    const {category, example, onChange, data = {}} = this.props;\n    const categories = Object.keys(data);\n    const selectedValue = `${category}.${example}`;\n\n    return (\n      <DropDown\n        value={selectedValue}\n        onChange={evt => {\n          const categoryExample = evt.target.value;\n          const value = categoryExample.split('.');\n          onChange({category: value[0], example: value[1]});\n        }}\n      >\n        {categories.map((c, i) => {\n          const categoryExamples = data[c].examples;\n          return (\n            <optgroup key={i} label={c}>\n              {Object.keys(categoryExamples).map((e, j) => {\n                const value = `${c}.${e}`;\n                return (\n                  <option key={j} value={value}>\n                    {e}\n                  </option>\n                );\n              })}\n            </optgroup>\n          );\n        })}\n      </DropDown>\n    );\n  }\n\n  _renderDropped() {\n    const {droppedFile} = this.props;\n    return droppedFile ? <div>Dropped file: {JSON.stringify(droppedFile.name)}</div> : null;\n  }\n\n  render() {\n    return (\n      <Container>\n        {this._renderByCategories()}\n        {this._renderDropped()}\n      </Container>\n    );\n  }\n}\n","/* global fetch */\nimport React, {PureComponent} from 'react';\nimport {render} from 'react-dom';\nimport DeckGL from '@deck.gl/react';\nimport {COORDINATE_SYSTEM, OrbitView, LinearInterpolator} from '@deck.gl/core';\nimport {PointCloudLayer} from '@deck.gl/layers';\n\nimport {\n  Tile3DLoader,\n  Tile3DFeatureTable,\n  Tile3DBatchTable,\n  parseRGB565\n} from '@loaders.gl/3d-tiles';\nimport {load, registerLoaders} from '@loaders.gl/core';\n\nimport ControlPanel from './control-panel';\nimport fileDrop from './file-drop';\n\nfunction parseSync(arrayBuffer, options, url, loader) {\n  const result = Tile3DLoader.parseSync(arrayBuffer, options, url, loader);\n  return result;\n}\n\nexport const MeshTile3DLoader = {\n  name: '3D Tile Pointloud',\n  extensions: ['pnts'],\n  parseSync,\n  binary: true\n};\n\nregisterLoaders(MeshTile3DLoader);\n\nconst DATA_URI = 'https://raw.githubusercontent.com/uber-web/loaders.gl/master';\nconst INDEX_FILE = `${DATA_URI}/modules/3d-tiles/test/data/index.json`;\n\nconst INITIAL_VIEW_STATE = {\n  target: [0, 0, 0],\n  rotationX: 0,\n  rotationOrbit: 0,\n  orbitAxis: 'Y',\n  fov: 50,\n  minZoom: -10,\n  maxZoom: 10,\n  zoom: 1\n};\n\nconst transitionInterpolator = new LinearInterpolator(['rotationOrbit']);\n\nfunction getDataRange(data, step = 3) {\n  const mins = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\n  const maxs = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\n  const numOfPoints = data.length / step;\n  for (let i = 0; i < numOfPoints; i++) {\n    mins[0] = Math.min(mins[0], data[i * step]);\n    mins[1] = Math.min(mins[1], data[i * step + 1]);\n    mins[2] = Math.min(mins[2], data[i * step + 2]);\n\n    maxs[0] = Math.max(maxs[0], data[i * step]);\n    maxs[1] = Math.max(maxs[1], data[i * step + 1]);\n    maxs[2] = Math.max(maxs[2], data[i * step + 2]);\n  }\n\n  return {mins, maxs};\n}\n\nexport default class App extends PureComponent {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      viewState: INITIAL_VIEW_STATE,\n      featureTable: null,\n      batchTable: null,\n      tile: null,\n      droppedFile: null,\n      example: 'PointCloudNormals',\n      category: 'PointCloud'\n    };\n\n    this._deckRef = null;\n\n    this._onLoad = this._onLoad.bind(this);\n    this._onViewStateChange = this._onViewStateChange.bind(this);\n    this._rotateCamera = this._rotateCamera.bind(this);\n    this._getColor = this._getColor.bind(this);\n\n    this._loadExample = this._loadExample.bind(this);\n    this._onSelectExample = this._onSelectExample.bind(this);\n  }\n\n  componentDidMount() {\n    fileDrop(this._deckRef.deckCanvas, (promise, file) => {\n      this.setState({droppedFile: file, tile: null});\n      load(promise, MeshTile3DLoader).then(this._onLoad);\n    });\n\n    // fetch index file\n    fetch(INDEX_FILE)\n      .then(resp => resp.json())\n      .then(data => {\n        this.setState({data});\n        const {category, example} = this.state;\n        this._loadExample(category, example);\n      });\n  }\n\n  _onViewStateChange({viewState}) {\n    this.setState({viewState});\n  }\n\n  _rotateCamera() {\n    const {viewState} = this.state;\n    this.setState({\n      viewState: {\n        ...viewState,\n        rotationOrbit: viewState.rotationOrbit + 30,\n        transitionDuration: 600,\n        transitionInterpolator,\n        onTransitionEnd: this._rotateCamera\n      }\n    });\n  }\n\n  _loadExample(category, example) {\n    const {data} = this.state;\n    this.setState({tile: null});\n\n    if (data && category && example) {\n      const selectedExample = data[category].examples[example];\n      // eslint-disable-next-line no-undef\n      const url = `${DATA_URI}/${selectedExample.path}/${selectedExample.files[0]}`;\n      load(url).then(this._onLoad);\n    }\n  }\n\n  _onLoad(tile) {\n    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n    let batchTable = null;\n    if (tile.batchTableBinaryByteLength) {\n      const {batchTableJson, batchTableBinary} = tile;\n      batchTable = new Tile3DBatchTable(\n        batchTableJson,\n        batchTableBinary,\n        featureTable.getGlobalProperty('BATCH_LENGTH')\n      );\n    }\n\n    const {mins, maxs} = getDataRange(tile.positions);\n    let {viewState} = this.state;\n\n    if (mins && maxs) {\n      // File contains bounding box info\n      viewState = {\n        ...viewState,\n        target: [(mins[0] + maxs[0]) / 2, (mins[1] + maxs[1]) / 2, (mins[2] + maxs[2]) / 2],\n        /* global window */\n        zoom: Math.log2(window.innerWidth / (maxs[0] - mins[0])) - 1.5\n      };\n    }\n\n    tile.pointsCount = tile.featureTableJson.POINTS_LENGTH;\n\n    this.setState(\n      {\n        tile,\n        featureTable,\n        batchTable,\n        viewState\n      },\n      this._rotateCamera\n    );\n  }\n\n  /* eslint-disable max-statements */\n  _getColor(object, {index, data, target}) {\n    if (!this.state.tile) {\n      return null;\n    }\n\n    const {\n      tile: {colors, isRGB565, constantRGBA, batchIds},\n      batchTable\n    } = this.state;\n    if (colors) {\n      if (isRGB565) {\n        const color = parseRGB565(data.colors.value[index]);\n        target[0] = color[0];\n        target[1] = color[1];\n        target[2] = color[2];\n        target[3] = 255;\n      } else {\n        target[0] = data.colors.value[index * 3];\n        target[1] = data.colors.value[index * 3 + 1];\n        target[2] = data.colors.value[index * 3 + 2];\n        target[3] = data.colors.size === 4 ? data.colors[index * 3 + 4] : 255;\n      }\n\n      return target;\n    }\n\n    if (constantRGBA) {\n      return constantRGBA;\n    }\n\n    if (batchIds && batchTable) {\n      const batchId = batchIds[index];\n      // TODO figure out what is `dimensions` used for\n      const dimensions = batchTable.getProperty(batchId, 'dimensions');\n      const color = dimensions.map(d => d * 255);\n      return [...color, 255];\n    }\n\n    return [255, 255, 255];\n  }\n\n  /* eslint-enable max-statements */\n\n  _renderLayers() {\n    if (!this.state.tile) {\n      return null;\n    }\n\n    const {pointsCount, positions, colors, normals} = this.state.tile;\n\n    return (\n      positions &&\n      new PointCloudLayer({\n        data: {\n          colors: {value: colors, size: 4},\n          normals: {value: positions, size: 3},\n          length: positions.length / 3\n        },\n        id: '3d-point-cloud-layer',\n        coordinateSystem: COORDINATE_SYSTEM.IDENTITY,\n        numInstances: pointsCount,\n        instancePositions: positions,\n        getColor: this._getColor,\n        getNormal: normals\n          ? (object, {index, data, target}) => {\n              target[0] = data.normals[index * 3];\n              target[1] = data.normals[index * 3 + 1];\n              target[2] = data.normals[index * 3 + 2];\n              return target;\n            }\n          : [0, 1, 0],\n        opacity: 0.5,\n        pointSize: 1.5\n      })\n    );\n  }\n\n  _onSelectExample({category, example}) {\n    this.setState({category, example}, () => {\n      const {data} = this.state;\n      if (data && category && example) {\n        this._loadExample(category, example);\n      }\n    });\n  }\n\n  _renderControlPanel() {\n    const {data, example, category} = this.state;\n    return (\n      <ControlPanel\n        data={data}\n        category={category}\n        example={example}\n        onChange={this._onSelectExample}\n      />\n    );\n  }\n\n  render() {\n    const {viewState} = this.state;\n\n    return (\n      <DeckGL\n        ref={_ => (this._deckRef = _)}\n        width=\"100%\"\n        height=\"100%\"\n        views={new OrbitView()}\n        viewState={viewState}\n        controller={true}\n        onViewStateChange={this._onViewStateChange}\n        layers={this._renderLayers()}\n        parameters={{\n          clearColor: [0.07, 0.14, 0.19, 1]\n        }}\n      />\n    );\n  }\n}\n\nexport function renderToDOM(container) {\n  render(<App />, container);\n}\n","// Add drag and drop functions for given canvas\nexport default function fileDrop(canvas, onDrop) {\n  canvas.ondragover = e => {\n    e.dataTransfer.dropEffect = 'link';\n    e.preventDefault();\n  };\n\n  canvas.ondrop = e => {\n    e.preventDefault();\n    if (e.dataTransfer.files && e.dataTransfer.files.length === 1) {\n      const file = e.dataTransfer.files[0];\n      const readPromise = new Promise(resolve => {\n        const reader = new window.FileReader();\n        reader.onload = ev => resolve(ev.target.result);\n        reader.readAsArrayBuffer(file);\n      });\n\n      onDrop(readPromise, file);\n    }\n  };\n}\n","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object');\nvar $keys = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n","require('./_typed-array')('Uint16', 2, function (init) {\n  return function Uint16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","'use strict';\nvar global = require('./_global');\nvar has = require('./_has');\nvar cof = require('./_cof');\nvar inheritIfRequired = require('./_inherit-if-required');\nvar toPrimitive = require('./_to-primitive');\nvar fails = require('./_fails');\nvar gOPN = require('./_object-gopn').f;\nvar gOPD = require('./_object-gopd').f;\nvar dP = require('./_object-dp').f;\nvar $trim = require('./_string-trim').trim;\nvar NUMBER = 'Number';\nvar $Number = global[NUMBER];\nvar Base = $Number;\nvar proto = $Number.prototype;\n// Opera ~12 has broken Object#toString\nvar BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;\nvar TRIM = 'trim' in String.prototype;\n\n// 7.1.3 ToNumber(argument)\nvar toNumber = function (argument) {\n  var it = toPrimitive(argument, false);\n  if (typeof it == 'string' && it.length > 2) {\n    it = TRIM ? it.trim() : $trim(it, 3);\n    var first = it.charCodeAt(0);\n    var third, radix, maxCode;\n    if (first === 43 || first === 45) {\n      third = it.charCodeAt(2);\n      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if (first === 48) {\n      switch (it.charCodeAt(1)) {\n        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i\n        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i\n        default: return +it;\n      }\n      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {\n        code = digits.charCodeAt(i);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if (code < 48 || code > maxCode) return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\nif (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {\n  $Number = function Number(value) {\n    var it = arguments.length < 1 ? 0 : value;\n    var that = this;\n    return that instanceof $Number\n      // check on 1..constructor(foo) case\n      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)\n        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);\n  };\n  for (var keys = require('./_descriptors') ? gOPN(Base) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES6 (in case, if modules with ES6 Number statics required before):\n    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'\n  ).split(','), j = 0, key; keys.length > j; j++) {\n    if (has(Base, key = keys[j]) && !has($Number, key)) {\n      dP($Number, key, gOPD(Base, key));\n    }\n  }\n  $Number.prototype = proto;\n  proto.constructor = $Number;\n  require('./_redefine')(global, NUMBER, $Number);\n}\n","require('./_typed-array')('Int16', 2, function (init) {\n  return function Int16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Int8', 1, function (init) {\n  return function Int8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","// 20.1.2.2 Number.isFinite(number)\nvar $export = require('./_export');\nvar _isFinite = require('./_global').isFinite;\n\n$export($export.S, 'Number', {\n  isFinite: function isFinite(it) {\n    return typeof it == 'number' && _isFinite(it);\n  }\n});\n","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export');\nvar core = require('./_core');\nvar fails = require('./_fails');\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n","require('./_typed-array')('Int32', 4, function (init) {\n  return function Int32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Float64', 8, function (init) {\n  return function Float64Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', { fill: require('./_array-fill') });\n\nrequire('./_add-to-unscopables')('fill');\n","var $export = require('./_export');\nvar defined = require('./_defined');\nvar fails = require('./_fails');\nvar spaces = require('./_string-ws');\nvar space = '[' + spaces + ']';\nvar non = '\\u200b\\u0085';\nvar ltrim = RegExp('^' + space + space + '*');\nvar rtrim = RegExp(space + space + '*$');\n\nvar exporter = function (KEY, exec, ALIAS) {\n  var exp = {};\n  var FORCE = fails(function () {\n    return !!spaces[KEY]() || non[KEY]() != non;\n  });\n  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];\n  if (ALIAS) exp[ALIAS] = fn;\n  $export($export.P + $export.F * FORCE, 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function (string, TYPE) {\n  string = String(defined(string));\n  if (TYPE & 1) string = string.replace(ltrim, '');\n  if (TYPE & 2) string = string.replace(rtrim, '');\n  return string;\n};\n\nmodule.exports = exporter;\n","module.exports = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n  '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n","function _readOnlyError(name) {\n  throw new Error(\"\\\"\" + name + \"\\\" is read-only\");\n}\n\nmodule.exports = _readOnlyError;"],"sourceRoot":""}